package protocol.client;

import protocol.ByteArrayWrapper;
import protocol.Ding12Imple;
import protocol.ProtocolConfiguration;
import protocol.ServersResponseScs;
import protocol.polynomial.ClassicalPolynomial;
import protocol.polynomial.NttPolynomial;
import protocol.polynomial.PolynomialConfig;
import protocol.random.RandomCustom;
import protocol.server.Server;

import java.math.BigInteger;
import java.util.List;
import java.util.stream.IntStream;

import static protocol.polynomial.Utils.*;


/**
 * The {@code ClientImple} class represents a client in client–server protocol communication.
 * It defines the sizes of the public seed (used to generate the public polynomial {@code a})
 * and the client’s salt.
 *
 * <p>This class provides methods for client enrollment and login via
 * {@link #enroll(ClientsKnowledge)} and {@link #login(ClientsKnowledge)}.</p>
 *
 * <p>Parameters:</p>
 * <ul>
 *   <li>{@code PUBLICSEEDFORASIZE} – {@code int}, size of the public seed generated by the client,
 *       used to generate the public polynomial {@code a}</li>
 *   <li>{@code SALTSIZE} – {@code int}, size of the client’s salt</li>
 * </ul>
 *
 * @author Martin Zimka
 */
public class ClientImple {

    private static final int PUBLICSEEDFORASIZE = 34;  // Size could be changed however you wish.
    private static final int SALTSIZE = 34;  // Size could be changed however you wish.

    private final Server server;
    private final RandomCustom randomCustomImple;
    private final int n;
    private final ByteArrayWrapper publicSeedForA;
    private final Ding12Imple ding12;
    private final PolynomialConfig polynomialConfig;

    public ClientImple(RandomCustom random, Server server) {
        this.server = server;
        ProtocolConfiguration protocolConfiguration = server.getProtocolConfiguration();
        this.n = protocolConfiguration.getN();
        BigInteger q = protocolConfiguration.getQ();
        this.randomCustomImple = random;
        this.publicSeedForA = new ByteArrayWrapper(randomCustomImple, PUBLICSEEDFORASIZE);
        this.polynomialConfig = new PolynomialConfig(this.n, q);
        this.ding12 = new Ding12Imple(q);
    }

    private ByteArrayWrapper computeSeed1(ClientsKnowledge ck, ByteArrayWrapper salt) {
        ByteArrayWrapper identity = ck.getIdentity();
        ByteArrayWrapper password = ck.getPassword();
        // seed1 = SHA3-256(salt||SHA3-256(I||pwd)) //
        return salt.concatWith(identity.concatWith(password).hashWrapped()).hashWrapped();
    }

    private NttPolynomial computeVNttFromANttAndSalt(ClientsKnowledge ck, NttPolynomial aNtt, ByteArrayWrapper salt) {
        // v = asv + 2ev //
        // Compute seeds.
        ByteArrayWrapper seed1 = computeSeed1(ck, salt);
        ByteArrayWrapper seed2 = seed1.hashWrapped();
        // Based on seeds (computed from private values) generate sv, ev.
        NttPolynomial svNtt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple, seed1);
        NttPolynomial evNtt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple, seed2);
        // Do all the math.
        NttPolynomial constantTwoPolyNtt = NttPolynomial.constantTwoNtt(polynomialConfig);
        return multiply2NttTuplesAddThemTogetherNtt(aNtt, svNtt, constantTwoPolyNtt, evNtt);
    }

    private SessionConfigurationClient computeSharedSecret(ClientsKnowledge ck) {
        NttPolynomial constantTwoPolyNtt = NttPolynomial.constantTwoNtt(polynomialConfig);
        // pi = as1 + 2e1 //
        // Create polynomial a from public seed.
        NttPolynomial aNtt = generateUniformPolyNtt(polynomialConfig, randomCustomImple, publicSeedForA);
        // Compute s1.
        NttPolynomial s1Ntt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple);
        // Compute e1.
        NttPolynomial e1Ntt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple);
        // Do all the math.
        NttPolynomial piNtt = multiply2NttTuplesAddThemTogetherNtt(aNtt, s1Ntt, constantTwoPolyNtt, e1Ntt);
        // Send identity and ephemeral public key pi in NTT form to the server. //
        // Receive salt, ephemeral public key pj in NTT form and wj. //
        ServersResponseScs serversResponseScs = server.computeSharedSecret(ck.getIdentity(), piNtt);
        if (serversResponseScs == null) {  // Client was not found in the server's database.
            return null;
        }
        ByteArrayWrapper salt = serversResponseScs.getSalt();
        NttPolynomial pjNtt = serversResponseScs.getPjNtt();
        List<Integer> wj = serversResponseScs.getWj();
        // u = XOF(H(pi || pj)) //
        NttPolynomial uNtt = computeUNtt(polynomialConfig, randomCustomImple, piNtt, pjNtt);
        // v = asv + 2ev //
        NttPolynomial vNtt = computeVNttFromANttAndSalt(ck, aNtt, salt);
        // ki = (pj − v)(sv + s1) + uv + 2e1'' //
        // Compute e1''.
        NttPolynomial e1DoublePrimeNtt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple);
        // Compute sv.
        NttPolynomial svNtt = generateRandomErrorPolyNtt(polynomialConfig, randomCustomImple, computeSeed1(ck, salt));
        // Do all the math.
        NttPolynomial fstBracket = pjNtt.subtract(vNtt);
        NttPolynomial sndBracket = svNtt.add(s1Ntt);
        ClassicalPolynomial ki = multiply3NttTuplesAndAddThemTogether(polynomialConfig, fstBracket, sndBracket, uNtt, vNtt, constantTwoPolyNtt, e1DoublePrimeNtt);
        // sigmai = Mod_2(ki, wj) //
        List<Integer> sigmai = IntStream.range(0, n).mapToObj(i -> ding12.robustExtractor(ki.getCoefficients().get(i), wj.get(i))).toList();
        // ski = SHA3-256(sigmai) //
        ByteArrayWrapper ski = new ByteArrayWrapper(sigmai).hashWrapped();
        return new SessionConfigurationClient(piNtt, pjNtt, ski, serversResponseScs.getScs());
    }

    private LoginResponse verifyEntities(SessionConfigurationClient scs) {
        NttPolynomial piNtt = scs.getClientsEphPubKey();
        NttPolynomial pjNtt = scs.getServersEphPubKey();
        ByteArrayWrapper ski = scs.getSharedSecret();
        // M1 = SHA3-256(pi || pj || ski) //
        ByteArrayWrapper m1 = piNtt.concatWith(pjNtt).toByteArrayWrapper().concatWith(ski).hashWrapped();
        // M2 = SHA3-256(pi || M1 || ski) //
        ByteArrayWrapper m2Prime = server.verifyEntities(scs.getServersSessionConfiguration(), m1);
        ByteArrayWrapper m2 = piNtt.toByteArrayWrapper().concatWith(m1).concatWith(ski).hashWrapped();
        // VERIFY that M2 == M2'.
        return new LoginResponse(m2.equals(m2Prime), ski);
    }

    /**
     * Enrolls the client — Phase 0 of <a href="https://eprint.iacr.org/2017/1196.pdf">the protocol</a>.
     *
     * <p>During enrollment, the client computes a verifier {@code v} as:</p>
     * {@code v = a·sv + 2·ev},
     * where:
     * <ul>
     *   <li>{@code a} – public polynomial generated from a seed,</li>
     *   <li>{@code sv} – secret polynomial derived from the client’s knowledge and salt,</li>
     *   <li>{@code ev} – error polynomial derived from the client’s knowledge and salt.</li>
     * </ul>
     *
     * <p>The verifier, together with the client’s identity, salt, and the public seed for {@code a},
     * is then sent to the server.</p>
     * <p> Verifier and salt are forgotten!</p>
     *
     * @param ck the client’s identity and password, encapsulated in a {@link ClientsKnowledge} object
     */
    public void enroll(ClientsKnowledge ck) {
        // PHASE 0 //
        // v = asv + 2ev //
        // Create polynomial a from public seed.
        NttPolynomial aNtt = generateUniformPolyNtt(polynomialConfig, randomCustomImple, publicSeedForA);
        // Generate salt.
        ByteArrayWrapper salt = new ByteArrayWrapper(randomCustomImple, SALTSIZE);
        // Compute v.
        NttPolynomial vNtt = computeVNttFromANttAndSalt(ck, aNtt, salt);
        // Send public seed for a, identity, salt and v in NTT form to the server. //
        server.enrollClient(publicSeedForA, ck.getIdentity(), salt, vNtt);
    }

    /**
     * Performs the client login procedure — Phases 1 and 2 of
     * <a href="https://eprint.iacr.org/2017/1196.pdf">the protocol</a>.
     *
     * <p><b>Phase 1 – Computing the shared secret</b></p>
     * <ol>
     *   <li>Compute the client’s ephemeral public key {@code pi}.</li>
     *   <li>Send {@code pi} (in NTT form) to the server.</li>
     *   <li>Receive from the server:
     *     <ul>
     *       <li>the client’s salt,</li>
     *       <li>{@code pj} – the server’s ephemeral public key,</li>
     *       <li>{@code wj} – coefficients resulting from the Signal function,</li>
     *       <li>a server-side session configuration (allowing the server to continue with other clients).</li>
     *     </ul>
     *   </li>
     *   <li>Compute key exchange material {@code ki}, which requires recomputing the verifier and
     *       calculating {@code u}.</li>
     *   <li>Hash secret {@code sigmai} extracted from {@code ki} and {@code wj}.</li>
     * </ol>
     *
     * <p><b>Phase 2 – Verifying entities</b></p>
     * <ol>
     *   <li>Compute {@code M1} = hash(client’s ephemeral key, server’s ephemeral key, client’s shared secret).</li>
     *   <li>Send {@code M1} along with the session configuration to the server.</li>
     *   <li>Receive {@code M2} from the server (or {@code null} if authentication failed).</li>
     *   <li>Locally compute {@code M2'} = hash(client’s ephemeral key, {@code M1}, client’s shared secret).</li>
     *   <li>If {@code M2 = M2'}, the login succeeds and mutual authentication is established; otherwise,
     *       the login fails.</li>
     * </ol>
     *
     * @param ck the client’s identity and password, encapsulated in a {@link ClientsKnowledge} object
     * @return a {@link LoginResponse} containing the login status and the computed shared secret
     */
    public LoginResponse login(ClientsKnowledge ck) {
        // PHASE 1 //
        SessionConfigurationClient scc = computeSharedSecret(ck);
        if (scc == null) {  // Client was not found in the server's database.
            return new LoginResponse(false, null);
        }
        // PHASE 2 //
        return verifyEntities(scc);
    }
}
