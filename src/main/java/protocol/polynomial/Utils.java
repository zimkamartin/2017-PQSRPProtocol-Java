package protocol.polynomial;

import protocol.ByteArrayWrapper;
import protocol.random.RandomCustom;

import java.math.BigInteger;
import java.util.List;

/** * The {@code Utils} class is utility class for polynomials in mostly NTT form.
 * <p>All math related single-polynomial operations are in the class NttPolynomial. Here are:<\p>
 *
 * <ul>
 *   <li>{@link #multiply2NttTuplesAddThemTogetherNtt(NttPolynomial, NttPolynomial, NttPolynomial, NttPolynomial)} –
 *       multiplies two pairs of NTT polynomials and adds the results</li>
 *   <li>{@link #multiply3NttTuplesAndAddThemTogether(PolynomialConfig, NttPolynomial, NttPolynomial,
 *       NttPolynomial, NttPolynomial, NttPolynomial, NttPolynomial)} –
 *       multiplies three pairs of NTT polynomials, adds the results and converts to standard form</li>
 *   <li>{@link #generateRandomErrorPolyNtt(PolynomialConfig, RandomCustom, ByteArrayWrapper)} –
 *       generates a random error polynomial (by Center Binomial Distribution) in NTT form using the given seed</li>
 *   <li>{@link #generateRandomErrorPolyNtt(PolynomialConfig, RandomCustom)} –
 *       generates a random error polynomial by creating a random seed and
 *       delegating to the previous method</li>
 *   <li>{@link #generateUniformPolyNtt(PolynomialConfig, RandomCustom, ByteArrayWrapper)} –
 *       generates a random polynomial (by Uniform distribution) in NTT form</li>
 *   <li>{@link #computeUNtt(PolynomialConfig, RandomCustom, NttPolynomial, NttPolynomial)} –
 *       computes the parameter {@code u} as defined in the protocol</li>
 * </ul>
 *
 * @author Martin Zimka
 */
public final class Utils {

    private Utils() {}

    /**
     * Multiplies two pairs of NTT polynomials and adds the results.
     *
     * @param a polynomial in NTT domain
     * @param b polynomial in NTT domain
     * @param c polynomial in NTT domain
     * @param d polynomial in NTT domain
     * @return ab + cd, where each polynomial is in NTT form
     */
    public static NttPolynomial multiply2NttTuplesAddThemTogetherNtt(NttPolynomial a, NttPolynomial b, NttPolynomial c, NttPolynomial d) {
        NttPolynomial ab = a.multiply(b);
        NttPolynomial cd = c.multiply(d);
        return ab.add(cd);
    }

    /**
     * Multiplies three pairs of NTT polynomials, adds the results and converts it to the standard form of a polynomial.
     *
     * @param a polynomial in NTT domain
     * @param b polynomial in NTT domain
     * @param c polynomial in NTT domain
     * @param d polynomial in NTT domain
     * @param e polynomial in NTT domain
     * @param f polynomial in NTT domain
     * @return fromNtt(ab + cd + ef), where each polynomial is in NTT form
     */
    public static ClassicalPolynomial multiply3NttTuplesAndAddThemTogether(PolynomialConfig pc, NttPolynomial a, NttPolynomial b, NttPolynomial c, NttPolynomial d, NttPolynomial e, NttPolynomial f) {
        NttPolynomial addedFstTwo = multiply2NttTuplesAddThemTogetherNtt(a, b, c, d);
        NttPolynomial ef = e.multiply(f);
        return new ClassicalPolynomial(addedFstTwo.add(ef), pc);
    }

    /**
     * From seed generates polynomial in NTT form where coefficients are distributed by CBD (Center Binomial Distribution).
     *
     * @param pc instance of a PolynomialConfig object
     * @param rc instance of a class implementing RandomCustom interface
     * @param seed CBD generator will be seeded by this
     * @return NTT domain polynomial - its coefficients are generated by CBD from provided seed
     */
    public static NttPolynomial generateRandomErrorPolyNtt(PolynomialConfig pc, RandomCustom rc, ByteArrayWrapper seed) {
        List<BigInteger> eCoeffs = rc.generateCbdCoefficients(pc.getN(), seed.getData().clone());
        return NttPolynomial.fromClassicalCoefficients(eCoeffs, pc);
    }

    /**
     * Generates random seed and calls {@link #generateRandomErrorPolyNtt(PolynomialConfig, RandomCustom, ByteArrayWrapper)}.
     *
     * @param pc instance of a PolynomialConfig object
     * @param rc instance of a class implementing RandomCustom interface
     * @return NTT domain polynomial - its coefficients are generated by CBD from randomly generated seed
     */
    public static NttPolynomial generateRandomErrorPolyNtt(PolynomialConfig pc, RandomCustom rc) {
        return generateRandomErrorPolyNtt(pc, rc, new ByteArrayWrapper(rc, 34));
    }

    /**
     * From seed generates polynomial in NTT form where coefficients are distributed by Uniform distribution.
     *
     * @param pc instance of a PolynomialConfig object
     * @param rc instance of a class implementing RandomCustom interface
     * @param seed Uniform distribution generator will be seeded by this
     * @return NTT domain polynomial - its coefficients are generated by Uniform distribution from provided seed
     */
    public static NttPolynomial generateUniformPolyNtt(PolynomialConfig pc, RandomCustom rc, ByteArrayWrapper seed) {
        List<BigInteger> coeffs = rc.generateUniformCoefficients(pc.getN(), seed.getData());
        return NttPolynomial.fromNttCoefficients(coeffs, pc);
    }

    /**
     * Computes variable u from <a href="https://eprint.iacr.org/2017/1196.pdf">the protocol</a>.
     *
     * <p>u = XOF(H(pi || pj))</p>
     * <p>XOF will be seed to the Uniform NTT polynomial generator.</p>
     *
     * @param pc instance of a PolynomialConfig object
     * @param rc instance of a class implementing RandomCustom interface
     * @param pi client's ephemeral public key
     * @param pj server's ephemeral public key
     * @return computed u from the protocol
     */
    public static NttPolynomial computeUNtt(PolynomialConfig pc, RandomCustom rc, NttPolynomial pi, NttPolynomial pj) {
        ByteArrayWrapper seed = pi.concatWith(pj).toByteArrayWrapper().hashWrapped();
        return generateUniformPolyNtt(pc, rc, seed);
    }
}
